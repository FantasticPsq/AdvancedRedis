### Redis 字符串 ###
1. 简介
```text
Redis中的默认字符串是一种名为 简单动态字符串（simple dynamic string,SDS) 的
抽象数据类型，与c语言的传统字符串不同。Redis中c字符串只会作为字符串字面量用在一些
无需对字符串进行修改的地方，比如打印日志中的提示字符串等。而其他包含字符串的键值在
底层都是由SDS实现的。例如如果执行了如下命令：
```
```redis
>SET fruits "apple" "banana" "cherry"
```
```text
那么Redis将在数据库中创建一个新的键值对，其中：
1.键值对的键是一个字符串对象，对象的底层实现是一个保存了字符串"fruits"的SDS。
2.键值对的至是一个列表对象，列表对象包含了三个字符串对象，这三个字符串对象分别由
三个SDS实现。"
```
```text
除了用来保存数据库中的字符串值之外，SDS还被用作缓冲区(buffer):AOF模块中的
AOF 缓冲区，以及 客户端状态中的缓冲区 ，都是由SDS实现的。
```

2. SDS定义
```c
// sds.h/sdshdr
struct sdshdr{
    // len表示字符串的长度，不包括'\0'
    int len;
    // free表示buf数组中未使用字节的数量
    int free;
    // 字节数组，用于保存字符串
    char buf[];
}
```
要点：
```text
1. SDS遵循C字符串以空字符结尾的惯例，保存空字符的1字节空间不计算在SDS的len属性
里面，并且为空字符串分配额外的1字节空间，以及添加空字符串到字符串末尾等操作，都是
由SDS函数自动完成的，所以这个空字符串对于SDS的使用者来说是完全透明的。
```

3. **SDS与C字符串的区别**
    1. 常数复杂度获取字符串长度：我们知道c语言字符串要获取字符串的长度的复杂度为O(N),
    但是SDS在len属性中记录了SDS本身的长度，所以获取一个SDS长度的复杂度为O(1)
    
    2. 杜绝缓冲区溢出：除了获取字符串长度的复杂度高之外，C字符串不记录自身长度带来的另外
    一个问题便是容易造成缓冲区溢出(buffer overflow)：比如执行strcat(char *dest,const char *src);
    因为C字符串不记录自身的长度，所以strcat假定用户在执行这个函数时，已经为dest分配了
    足够的空间，可以容纳src字符串中的所有内容，而一旦假设不成立，就会产生缓冲区溢出。
    举个具体的例子：假设程序里有两个在内存中紧邻着的C字符串s1和s2,其中s1保存了字符串"Redis"，而
    s2保存了字符串"MongoDB",当执行strcat(s1,"HiCluster")时，会将s1的内容修改为"Redis HiCluster",
    但是如果没有在执行strcat之前为s1分配足够的空间，那么执行完后，s1将溢出到s2的空间中，导致s2
    被意外的修改了。
    而与C字符串不同，SDS的空间分配策略完全杜绝了发生缓冲区溢出的可能性：当SDS API需要对SDS进行修改时,
    API会自动将SDS的空间拓展至执行修改所需要的大小，然后才执行实际的修改操作，所以使用SDS不会出现换从
    溢出的问题。
    
    3. 减少修改字符串时带来的内存重分配次数
    由于C字符串并没有记录自身的长度，所以对于一个包含了N个字符的C字符串来说，这个C字符串底层实现总是
    一个N+1个字符串的数组（额外的一个字符空间用于保存空字符串）。因为C字符串的长度和底层数组长度之间
    存在着这种关联性，所以每次增长或缩短一个字符串，都需要对保存这个字符串的数组进行一次内存的重分配操作：
        1. 如果执行的是增长字符串的操作，比如拼接操作（append),那么在执行这个操作之前，程序需要先通过内存
        重分配来扩展底层数组的空间大小——如果没有这一步，就会导致缓冲区溢出
        2.如果是缩短字符串的操作，那么执行这个操作之后，程序需要通过内存重分配来释放字符串不再使用的那部分空间
        ——没有这一步则会导致内存泄漏。
        
    



