### Redis 字符串 ###
1. 简介
```text
Redis中的默认字符串是一种名为 简单动态字符串（simple dynamic string,SDS) 的
抽象数据类型，与c语言的传统字符串不同。Redis中c字符串只会作为字符串字面量用在一些
无需对字符串进行修改的地方，比如打印日志中的提示字符串等。而其他包含字符串的键值在
底层都是由SDS实现的。例如如果执行了如下命令：
```
```redis
>SET fruits "apple" "banana" "cherry"
```
```text
那么Redis将在数据库中创建一个新的键值对，其中：
1.键值对的键是一个字符串对象，对象的底层实现是一个保存了字符串"fruits"的SDS。
2.键值对的至是一个列表对象，列表对象包含了三个字符串对象，这三个字符串对象分别由
三个SDS实现。"
```
```text
除了用来保存数据库中的字符串值之外，SDS还被用作缓冲区(buffer):AOF模块中的
AOF 缓冲区，以及 客户端状态中的缓冲区 ，都是由SDS实现的。
```

2. SDS定义
```c
// sds.h/sdshdr
struct sdshdr{
    // len表示字符串的长度，不包括'\0'
    int len;
    // free表示buf数组中未使用字节的数量
    int free;
    // 字节数组，用于保存字符串
    char buf[];
}
```
要点：
```text
1. SDS遵循C字符串以空字符结尾的惯例，保存空字符的1字节空间不计算在SDS的len属性
里面，并且为空字符串分配额外的1字节空间，以及添加空字符串到字符串末尾等操作，都是
由SDS函数自动完成的，所以这个空字符串对于SDS的使用者来说是完全透明的。
```

3. **SDS与C字符串的区别**
```text
1. 常数复杂度获取字符串长度：我们知道c语言字符串要获取字符串的长度的复杂度为O(N),
但是SDS在len属性中记录了SDS本身的长度，所以获取一个SDS长度的复杂度为O(1)

2. 杜绝缓冲区溢出：除了获取字符串长度的复杂度高之外，C字符串不记录自身长度带来的另外
一个问题便是容易造成缓冲区溢出(buffer overflow)：比如执行strcat(char *dest,const char *src);
因为C字符串不记录自身的长度，所以strcat假定用户在执行这个函数时，已经为dest分配了
足够的空间，可以容纳src字符串中的所有内容，而一旦假设不成立，就会产生缓冲区溢出。
举个具体的例子：假设程序里有两个在内存中紧邻着的C字符串s1和s2,其中s1保存了字符串"Redis"，而
s2保存了字符串"MongoDB",当执行strcat(s1,"HiCluster")时，会将s1的内容修改为"Redis HiCluster",
但是如果没有在执行strcat之前为s1分配足够的空间，那么执行完后，s1将溢出到s2的空间中，导致s2
被意外的修改了。
而与C字符串不同，SDS的空间分配策略完全杜绝了发生缓冲区溢出的可能性：当SDS API需要对SDS进行修改时,
API会自动将SDS的空间拓展至执行修改所需要的大小，然后才执行实际的修改操作，所以使用SDS不会出现换从
溢出的问题。

3. 减少修改字符串时带来的内存重分配次数
由于C字符串并没有记录自身的长度，所以对于一个包含了N个字符的C字符串来说，这个C字符串底层实现总是
一个N+1个字符串的数组（额外的一个字符空间用于保存空字符串）。因为C字符串的长度和底层数组长度之间
存在着这种关联性，所以每次增长或缩短一个字符串，都需要对保存这个字符串的数组进行一次内存的重分配操作：
    1. 如果执行的是增长字符串的操作，比如拼接操作（append),那么在执行这个操作之前，程序需要先通过内存
    重分配来扩展底层数组的空间大小——如果没有这一步，就会导致缓冲区溢出
    2.如果是缩短字符串的操作，那么执行这个操作之后，程序需要通过内存重分配来释放字符串不再使用的那部分空间
    ——没有这一步则会导致内存泄漏。
因为内存非陪涉及复杂的算法，并且可能执行系统调用，所以它通常是一个非常耗时的操作：Redis会经常涉及到字符串
的修改，如果使用C字符串，那么修改字符串的时间大部分都花费在内存重分配上了，这是不能接受的。
那么，SDS是怎么解决这个问题的呢？SDS通过未使用空间解除了字符串长度与底层数组长度之间的关系：
SDS中，buf的长度不一定是字符串长度+1，数组里面可以包含未使用字节，而这些字节的数量就是由SDS的free属性记录的。

通过未使用空间，SDS实现了 空间预分配 和 惰性空间释放 两种优化策略
    1. 空间预分配：主要是用于优化字符串增长的操作：当SDS的API对一个SDS进行修改，并且需要对
    SDS进行空间拓展的时候，程序不仅会为SDS分配修改所必要的空间，还会分配额外的未使用空间。分为以下两种情况：
        1. 如果，修改SDS之后，SDS的len属性小于1M，那么将会为SDS分配大小与len相同的未使用空间，也就是
        说此时free=len。此时buf的长度为free+len+1=2len+1
        2. 如果修改SDS之后，SDS的len属性大于等于1M,那么将会为SDS分配大小为1M的未使用空间，也就是free=1M
    通过空间预分配策略，Redis可以减少连续执行字符串增长操作所需的内存重分配次数。
    2. 惰性空间释放
    惰性空间释放用于优化SDS的字符串缩短操作：当SDS的API需要缩短SDS时，程序并不是直接回收缩短后多出来的空间，
    而是用free将这些多出来的未使用空间记录起来，并等待将来使用。（尝试与Python的垃圾回收机制对比）
    另外，SDS也提供了相应的API，让我们可以在有需要的时候，真正释放SDS的未使用空间1，所以不用担心
    惰性空间释放策略会造成内存泄漏。

4. 二进制安全
C字符串必须符合某种编码（比如ASCII)，并且除了字符串末尾之外，字符串里面不能包含空字符，否则最先被程序读入的
空字符串将被认为是字符串的结尾，这些限制使得C字符串只能保存文本数据，而不能保存图片、音频、视频、压缩文件这样的
二进制数据。但是SDS会以处理二进制的方式来处理SDS存放在buf数组里面的数据，程序不会对其中的数据进行任何限制、
过滤、或者假设，数据在写入时是什么样的，他被读取的时候就是什么样的。因为SDS使用len属性值而不是空字符串来判断
字符串是否结束。所以SDS是二进制安全的，不仅可以保存文本数据，还可以保存任意格式的二进制数据。
```

4. 总结   

| C字符串 | SDS |
| ------ | ------ |
| 获取字符串长度的复杂度为O(N) | 获取字符串长度的复杂度为O(1) | 
| API是不安全的，可能造成缓冲区溢出 | API是安全的，不会造成缓冲区溢出 | 
| 修改字符串N次必定会造成N次内存重分配 | 修改字符串长度N次最多需要N次内存重分配 |
| 只能保存文本数据 | 可以保存文本和二进制数据 |
| 可以使用所有<string.h>库中的函数 | 可以使用一部分<string.h>库中的函数 |
    
    
    



